/**
 * Security Vulnerability Regression Tests
 * 
 * These tests ensure that known security vulnerabilities remain fixed
 * and detect potential new security issues in the codebase.
 */

import { SecurityManager } from '../../src/modules/SecurityManager';
import { SecurityProfile, RiskLevel, DetectionAvoidanceStrategy } from '../../src/shared/types/Security';
import * as AntiDetection from '../../src/modules/utils/AntiDetection';
import * as ProcessIsolation from '../../src/modules/utils/ProcessIsolation';

describe('Security Vulnerability Regression Tests', () => {
  let securityManager: SecurityManager;
  let testProfiles: SecurityProfile[];

  beforeEach(() => {
       // Mock Electron process type for testing
       Object.defineProperty(process, 'type', {
         value: 'browser', // or 'renderer' depending on the test case
         configurable: true
       });
    // Create test security profiles
    testProfiles = [
      {
        name: 'low-risk',
        riskLevel: RiskLevel.Low,
        enabledStrategies: [DetectionAvoidanceStrategy.RandomizedDelays],
        description: 'Low risk profile for normal operations'
      },
      {
        name: 'high-risk',
        riskLevel: RiskLevel.High,
        enabledStrategies: [
          DetectionAvoidanceStrategy.RandomizedDelays,
          DetectionAvoidanceStrategy.CPUThrottling,
          DetectionAvoidanceStrategy.ProcessIsolation
        ],
        description: 'High risk profile with enhanced security measures'
      }
    ];

    securityManager = new SecurityManager(testProfiles, 'low-risk');
  });

  describe('Security Manager Core Functionality', () => {
    test('should initialize with correct default profile', () => {
      const currentProfile = securityManager.getCurrentProfile();
      expect(currentProfile.name).toBe('low-risk');
      expect(currentProfile.riskLevel).toBe(RiskLevel.Low);
    });

    test('should switch security profiles correctly', () => {
      securityManager.applyProfile('high-risk');
      const currentProfile = securityManager.getCurrentProfile();
      expect(currentProfile.name).toBe('high-risk');
      expect(currentProfile.riskLevel).toBe(RiskLevel.High);
    });

    test('should log security events', () => {
      securityManager.applyProfile('high-risk');
      const eventLog = securityManager.getEventLog();
      
      expect(eventLog.length).toBeGreaterThan(0);
      expect(eventLog[0].eventType).toBe('init');
      expect(eventLog[1].eventType).toBe('profile_change');
    });
  });

  describe('Detection Avoidance Security', () => {
    test('should run detection avoidance strategies without errors', async () => {
      await expect(securityManager.runDetectionAvoidance()).resolves.not.toThrow();
    });

    test('should complete detection avoidance within performance limits', async () => {
      const start = performance.now();
      await securityManager.runDetectionAvoidance();
      const elapsed = performance.now() - start;
      
      // Should complete quickly (allowing for some overhead)
      expect(elapsed).toBeLessThan(100); // 100ms threshold
    });

    test('should log performance warnings for slow operations', async () => {
      // Switch to high-risk profile with more strategies
      securityManager.applyProfile('high-risk');
      
      await securityManager.runDetectionAvoidance();
      const eventLog = securityManager.getEventLog();
      
      // Check if any performance warnings were logged
      const performanceWarnings = eventLog.filter(event => 
        event.eventType === 'performance_warning'
      );
      
      // Performance warnings may or may not occur depending on system load
      expect(performanceWarnings.length).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Process Isolation Security', () => {
    test('should check process isolation without errors', () => {
      expect(() => securityManager.checkProcessIsolation()).not.toThrow();
    });

    test('should detect process type correctly', () => {
      // Mock process detection
      const isMain = ProcessIsolation.isMainProcess();
      const isRenderer = ProcessIsolation.isRendererProcess();
      
      // At least one should be true in a valid Electron environment
      expect(isMain || isRenderer).toBe(true);
    });

    test('should check sandbox status', () => {
      const isSandboxed = ProcessIsolation.isSandboxed();
      expect(typeof isSandboxed).toBe('boolean');
    });
  });

  describe('System Monitoring Security', () => {
    test('should monitor system footprint', () => {
      const footprint = securityManager.monitorSystemFootprint();
      
      expect(footprint).toBeDefined();
      expect(typeof footprint.cpuUsagePercent).toBe('number');
      expect(typeof footprint.memoryUsageMB).toBe('number');
      expect(footprint.cpuUsagePercent).toBeGreaterThanOrEqual(0);
      expect(footprint.memoryUsageMB).toBeGreaterThanOrEqual(0);
    });

    test('should log warnings for high resource usage', () => {
      // Monitor with very low thresholds to trigger warnings
      securityManager.monitorSystemFootprint(1, 1);
      
      const eventLog = securityManager.getEventLog();
      const warnings = eventLog.filter(event => 
        event.eventType === 'cpu_warning' || event.eventType === 'memory_warning'
      );
      
      // Should have at least one warning with such low thresholds
      expect(warnings.length).toBeGreaterThan(0);
    });

    test('should store last footprint measurement', () => {
      securityManager.monitorSystemFootprint();
      const lastFootprint = securityManager.getLastFootprint();
      
      expect(lastFootprint).not.toBeNull();
      expect(lastFootprint?.cpuUsagePercent).toBeGreaterThanOrEqual(0);
      expect(lastFootprint?.memoryUsageMB).toBeGreaterThanOrEqual(0);
    });
  });

  describe('Risk Assessment Security', () => {
    test('should adjust behavior based on risk assessment', () => {
      // First monitor to get baseline
      securityManager.monitorSystemFootprint();
      
      // Then adjust behavior
      expect(() => securityManager.adjustBehaviorBasedOnRisk()).not.toThrow();
    });

    test('should escalate risk level for high resource usage', () => {
      // Create a profile that should trigger escalation
      const criticalProfile: SecurityProfile = {
        name: 'critical',
        riskLevel: RiskLevel.Critical,
        enabledStrategies: [DetectionAvoidanceStrategy.ProcessIsolation],
        description: 'Critical risk profile with maximum security'
      };

      const updatedProfiles = [...testProfiles, criticalProfile];
      const testManager = new SecurityManager(updatedProfiles, 'low-risk');
      
      // Monitor with high thresholds to simulate high usage
      testManager.monitorSystemFootprint(0, 0); // This should trigger high usage warnings
      testManager.adjustBehaviorBasedOnRisk();
      
      // The risk level should have been escalated
      const currentProfile = testManager.getCurrentProfile();
      expect([RiskLevel.Medium, RiskLevel.High, RiskLevel.Critical]).toContain(currentProfile.riskLevel);
    });
  });

  describe('Anti-Detection Utilities', () => {
    test('should generate system footprint data', () => {
      const footprint = AntiDetection.getSystemFootprint();
      
      expect(footprint).toBeDefined();
      expect(typeof footprint.cpuUsagePercent).toBe('number');
      expect(typeof footprint.memoryUsageMB).toBe('number');
      expect(footprint.cpuUsagePercent).toBeGreaterThanOrEqual(0);
      expect(footprint.cpuUsagePercent).toBeLessThanOrEqual(100);
    });

    test('should handle randomized delays', async () => {
      const start = Date.now();
      await AntiDetection.randomizedDelay(1, 5);
      const elapsed = Date.now() - start;
      
      // Should have some delay but not too much
      expect(elapsed).toBeGreaterThanOrEqual(1);
      expect(elapsed).toBeLessThan(20); // Allow some overhead
    });

    test('should handle CPU throttling', async () => {
      await expect(AntiDetection.cpuThrottling(1, 10)).resolves.not.toThrow();
    });

    test('should adjust process priority', () => {
      expect(() => AntiDetection.adjustProcessPriority('low')).not.toThrow();
    });
  });

  describe('Input Validation Security', () => {
    test('should handle malicious input patterns safely', () => {
      const maliciousInputs = [
        '<script>alert("xss")</script>',
        "'; DROP TABLE users; --",
        '../../../etc/passwd',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
      ];

      // Test that the security manager doesn't crash with malicious inputs
      maliciousInputs.forEach(input => {
        expect(() => {
          // Simulate processing potentially malicious input
          const sanitized = input.replace(/[<>'"]/g, '');
          expect(sanitized).not.toContain('<script>');
        }).not.toThrow();
      });
    });
  });

  describe('Error Handling Security', () => {
    test('should handle invalid profile names gracefully', () => {
      expect(() => securityManager.applyProfile('non-existent-profile')).not.toThrow();
      
      // Should remain on current profile
      const currentProfile = securityManager.getCurrentProfile();
      expect(currentProfile.name).toBe('low-risk');
    });

    test('should handle empty event log requests', () => {
      const eventLog = securityManager.getEventLog();
      expect(Array.isArray(eventLog)).toBe(true);
      expect(eventLog.length).toBeGreaterThanOrEqual(0);
    });
  });
});